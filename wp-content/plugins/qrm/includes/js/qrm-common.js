var    BrowserDetect = {      init: function () {         this.browser = this.searchString(this.dataBrowser) || "An unknown browser";         this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "an unknown version";         this.OS = this.searchString(this.dataOS) || "an unknown OS";      },      searchString: function (data) {         for (var i = 0; i < data.length; i++) {            var dataString = data[i].string;            var dataProp = data[i].prop;            this.versionSearchString = data[i].versionSearch || data[i].identity;            if (dataString) {               if (dataString.indexOf(data[i].subString) != -1) return data[i].identity;            } else if (dataProp) return data[i].identity;         }      },      searchVersion: function (dataString) {         var index = dataString.indexOf(this.versionSearchString);         if (index == -1) return;         return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));      },      dataBrowser: [{         string: navigator.userAgent,         subString: "Chrome",         identity: "Chrome"      }, {         string: navigator.userAgent,         subString: "OmniWeb",         versionSearch: "OmniWeb/",         identity: "OmniWeb"      }, {         string: navigator.vendor,         subString: "Apple",         identity: "Safari",         versionSearch: "Version"      }, {         prop: window.opera,         identity: "Opera",         versionSearch: "Version"      }, {         string: navigator.vendor,         subString: "iCab",         identity: "iCab"      }, {         string: navigator.vendor,         subString: "KDE",         identity: "Konqueror"      }, {         string: navigator.userAgent,         subString: "Firefox",         identity: "Firefox"      }, {         string: navigator.vendor,         subString: "Camino",         identity: "Camino"      }, {         string: navigator.userAgent,         subString: "Netscape",         identity: "Netscape"      }, {         string: navigator.userAgent,         subString: "MSIE",         identity: "Explorer",         versionSearch: "MSIE"      }, {         string: navigator.userAgent,         subString: "Gecko",         identity: "Mozilla",         versionSearch: "rv"      }, {         string: navigator.userAgent,         subString: "Mozilla",         identity: "Netscape",         versionSearch: "Mozilla"      }],      dataOS: [{         string: navigator.platform,         subString: "Win",         identity: "Windows"      }, {         string: navigator.platform,         subString: "Mac",         identity: "Mac"      }, {         string: navigator.userAgent,         subString: "iPhone",         identity: "iPhone/iPod"      }, {         string: navigator.platform,         subString: "Linux",         identity: "Linux"      }]};function $$(id){   return Ext.getCmp(id);}function msg(t,m){   Ext.Msg.show({      title: t,      msg: '<center>'+m+'</center>',      width: 400,      buttons: Ext.Msg.OK,      icon: Ext.Msg.INFO   });}function msgLeft(t,m){   Ext.Msg.show({      title: t,      msg: m,      width: 400,      buttons: Ext.Msg.OK,      icon: Ext.Msg.INFO   });}function merge_options(obj1,obj2){   var obj3 = {};   for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }   for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }   return obj3;}function escapeRegExp(string) {   return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");}function replaceAll(find, replace, str) {   return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);}function getJSONSelection(id) {   var items = [];   Ext.Array.each($$(id).getSelectionModel().getSelection(), function (model) {      items.push(model.data);   });   return Ext.JSON.encode(items);}function getExplorerRisks(){   var risks = new Array();   Ext.Array.each($$('qrmID-RiskTable').getSelectionModel().getSelection(), function(item){      risks.push(item.data);   });   return risks;}function getExplorerRiskIDs(){   var risks = new Array();   Ext.Array.each($$('qrmID-RiskTable').getSelectionModel().getSelection(), function(item){      risks.push(item.data.riskID);   });   return risks;}function checkExplorerSelection(){   return ($$('qrmID-RiskTable').getSelectionModel().getSelection().length > 0);}function exportSVG(id){        var form = Ext.getBody().createChild({       tag: 'form',       method: 'POST',       action: "./exportSVGtoPNG",       children: [         {           tag: 'input',           type: 'hidden',           name: "svg"       }]   });   // Assign the data on the value so it doesn't get messed up in the html insertion   form.last(null, true).value = document.getElementById(id).innerHTML;   form.dom.submit();   form.remove();}function getRiskCodeAndDisplayInt(id) {   Ext.Ajax.request({      url: "./getRiskCode",      params: {         "RISKID": id,         "PROJECTID": QRM.global.projectID      },      success:function(response){         debugger;         var risk = Ext.JSON.decode(response.responseText);         if (riskEditor == null) {            riskEditor = Ext.create('QRM.view.editor.RiskEditor', {               title: 'Risk Editor'            });         }         riskEditor.show();         // Prepare the drop downs         $$('qrmID-RiskEditorRiskOwner').bindStore();         $$('qrmID-RiskEditorRiskManager').bindStore();         $$('qrmID-RiskEditorPrimCat').bindStore();         $$('qrmID-RiskEditorRiskOwner').bindStore(projectOwnersStore);         $$('qrmID-RiskEditorRiskManager').bindStore(projectManagersStore);         $$('qrmID-RiskEditorPrimCat').bindStore(projectCategoryStore);         Ext.Ajax.request({            url: "./getRisk",            params: {               "PROJECTID": QRM.global.projectID,               "RISKID": risk.riskID            },            success: function (resp) {               QRM.app.getRiskEditorController().setRisk(Ext.decode(resp.responseText));            }         });      }   });}function ownerFind(id, tol) {   muliFind(id, null, null, null, null, null, tol);}function managerFind(id, tol) {   muliFind(null, id, null, null, null, null, tol);}function statusFind(id, tol) {   muliFind(null, null, null, id, null, null, tol);}function categoryFind(id, tol) {   muliFind(null, null, id, null, null, null, tol);}function toleranceFind(tol) {   muliFind(null, null, null, null, null, null, tol);}function treatmentFind(x){   if (x == "Un Treated"){      muliFind(null, null, null, null, false, true, null);   }   if (x == "Treated"){      muliFind(null, null, null, null, true, false, null);   }}function projectToleranceFind(tol, projID) {   // Ensure that the risk explorer is not automatically updated until the   // tolerance conditions are set   qoQRM.explorerSetProject = false;   if (qrmProjectMap.get(projID) != null) {      project = qrmProjectMap.get(projID);      qoQRM.singlePhase = project.singlePhase;      updateSelectedProject();      muliFind(null, null, null, null, null, null, tol);   } else {      isc.RPCManager.sendRequest({         prompt: "Retrieving Risk Project",         showPrompt: true,         evalResult: false,         params: {            "PROJECTID": projID         },         callback: function (rpcResponse, data, rpcRequest) {            try {               project = JSON.parse(data, dateParser);               if (!project) {                  alert("The risk repository has been updated.\n The risk project you selected is no longer available.");                  getUserProjects();               } else {                  qoQRM.singlePhase = project.singlePhase;                  updateSelectedProject();                  qrmProjectMap.put(projID, project);               }               muliFind(null, null, null, null, null, null, tol);               setTolMatrix(project);            } catch (e) {               alert("Risk Table Line 1318" + e.message);               getUserProjects();            }         },         actionURL: "./getRiskProject"      });   }}function muliFind(owner, manager, category, status, treat, untreat, tolerance) {   debugger;   var expController = QRM.app.getExplorerController();   expController.suspendFilterPanelListener = true;   expController.projectSwitch = false;   $$('qrm-mainTabsID').setActiveTab(0);   // Clear Out everything first   $$("cbExtreme").setValue(false);   $$("cbHigh").setValue(false);   $$("cbSignificant").setValue(false);   $$("cbModerate").setValue(false);   $$("cbLow").setValue(false);   $$("cbActive").setValue(false);   $$("cbPending").setValue(false);   $$("cbInactive").setValue(false);   $$("cbTreated").setValue(true);   $$("cbUntreated").setValue(true);   $$("comboCategory").setValue(null);   $$("comboRiskOwner").setValue(null);   $$("comboRiskManager").setValue(null);   $$('txtRiskCode').setValue("");   if (treat != null && !treat) {      $$("cbTreated").setValue(false);   }   if (untreat != null && !untreat) {      $$("cbUntreated").setValue(false);   }   if (tolerance == null || tolerance == "Extreme") {      $$("cbExtreme").setValue(true);   }   if (tolerance == null || tolerance == "High") {      $$("cbHigh").setValue(true);   }   if (tolerance == null || tolerance == "Significant") {      $$("cbSignificant").setValue(true);   }   if (tolerance == null || tolerance == "Moderate") {      $$("cbModerate").setValue(true);   }   if (tolerance == null || tolerance == "Low") {      $$("cbLow").setValue(true);   }   if (status == null || status == "Active") {      $$("cbActive").setValue(true);   }   if (status == null || status == "Pending") {      $$("cbPending").setValue(true);   }   if (status == null || status == "In+Active" || status == "Inactive") {      $$("cbInactive").setValue(true);   }   if (owner != null) {      $$("comboRiskOwner").setValue(owner);   }   if (manager != null) {      $$("comboRiskManager").setValue(manager);   }   if (category != null) {      $$("comboCategory").setValue(category);   }   expController.populateGrid(QRM.global.projectID, Ext.getCmp('cbDescendants').value);   expController.suspendFilterPanelListener = false;   expController.projectSwitch = true;}function matrixFilter(impact, prob, treated, tol) {   QRM.app.getExplorerController().matrixFilter({      "DESCENDANTS": $$('cbDescendants').value,      "PROJECTID": QRM.global.projectID,      "OPERATION": "getRiskLiteFetch",      "TREATEDPROB": treated ? prob : -1,            "TREATEDIMPACT": treated ? impact : -1,                  "UNTREATEDPROB": treated ? -1 : prob,                        "UNTREATEDIMPACT": treated ? -1 : impact,                              "TREATED": treated   });      var selectedCellSelector = "rect.qrmMatElementID"+impact+prob;   QRM.global.selectedCellProb = prob;   QRM.global.selectedCellImpact = impact;   QRM.global.selectedCellTol = tol;   QRM.global.selectedCellTreated = treated;      if (treated){      selectedCellSelector = selectedCellSelector+"T";   } else {      selectedCellSelector = selectedCellSelector+"U";         }      d3.select(selectedCellSelector).attr("class",  "selectedMatCell");}function getRandomInt(min, max) {   return Math.floor(Math.random() * (max - min + 1)) + min;}function parseDate(input) {   var parts = input.split(' ')[0].split('-');   return new Date(parts[0], parts[1] - 1, parts[2]);}function simplifyDate(sdParam) {   var sd = sdParam;   try {      if (sd == null) {         sd = new Date();      }      var year = sd.getFullYear();      var month = sd.getMonth() + 1;      var day = sd.getDate();      var mStr = "";      if (month < 10) {         mStr = mStr + "0" + month;      } else {         mStr = mStr + month;      }      var dStr = "";      if (day < 10) {         dStr = dStr + "0" + day;      } else {         dStr = dStr + day;      }      return year + "-" + mStr + "-" + dStr;   } catch (e) {      return sd;   }}function Map() {   // members   this.keyArray = new Array();   // Keys   this.valArray = new Array();   // Values   this.put = function (key, val) {      var elementIndex = this.findIt(key);      if (elementIndex == (-1)) {         this.keyArray.push(key);         this.valArray.push(val);      } else {         this.valArray[elementIndex] = val;      }   };   this.get = function (key) {      var result = null;      var elementIndex = this.findIt(key);      if (elementIndex != (-1)) {         result = this.valArray[elementIndex];      }      return result;   };   this.remove = function (key) {      var elementIndex = this.findIt(key);      if (elementIndex != (-1)) {         this.keyArray = this.keyArray.removeAt(elementIndex);         this.valArray = this.valArray.removeAt(elementIndex);      }      return;   };   this.size = function () {      return (this.keyArray.length);   };   this.clear = function () {      while (this.keyArray.length > 0) {         this.keyArray.pop();         this.valArray.pop();      }   };   this.keySet = function () {      return (this.keyArray);   };   this.valSet = function () {      return (this.valArray);   };   this.showMe = function () {      var result = "";      for (var i = 0; i < this.keyArray.length; i++) {         result += "Key: " + this.keyArray[i] + "\tValues: " + this.valArray[i] + "\n";      }      return result;   };   this.findIt = function (key) {      var result = (-1);      for (var i = 0; i < this.keyArray.length; i++) {         if (this.keyArray[i] == key) {            result = i;            break;         }      }      return result;   };   this.removeAt = function (index) {      var part1 = this.slice(0, index);      var part2 = this.slice(index + 1);      return (part1.concat(part2));   };}function registerRiskInterest(riskID) {   try {      if (ajaxRequest.readyState == 3 || ajaxRequest.readyState == 2) {         ajaxRequest.abort();      }   } catch (e) {      //   }   ajaxRequest = null;   ajaxRequest = $.ajax({      url: "/pollNG?nocache=" + Math.random() + "&action=registerRisk&userID=" + userID + "&riskID=" + riskID,      type: "POST",      timeout: 60000,      dataType: "json",      success: function (m) {         ajaxRequest = null;      },      error: function (jqXHR, textStatus, errorThrown) {         if (textStatus == "timeout") {            isc.say("Connection to the serever lost. You will need to login to Quay Risk Manager. (MG001)", function () {               window.open("./login.jsp", "_self");            });         }      }   });}function startChatChannel() {   var pollRisk = 0;   try {      pollRisk = qoRiskController.riskID;   } catch (e) {      pollRisk = 0;   }   ajaxChatRequest = $.ajax({      url: "/pollNG?nocache=" + Math.random() + "&action=poll&userID=" + QRM.global.userID + "&riskID=" + pollRisk,      type: "POST",      timeout: 90000,      dataType: "json",      success: function (m) {         ajaxChatRequest = null;         if (m.sessionexpire) {            Ext.Msg.show({               title: 'Session Expired',               msg: '<center>Your session has expired.</center> <center>You will need to login to Quay Risk Manager.</center>',               width: 400,               buttons: Ext.Msg.OK,               fn: function (btn) {                  window.open("./login.jsp", "_self");               },               icon: Ext.Msg.INFO            });         }         if (m.message) {            Ext.Msg.show({               title: 'System Message',               msg: m.message,               width: 400,               buttons: Ext.Msg.OK,               icon: Ext.Msg.INFO            });            startChatChannel();            return;         }         if (m.timeout) {            startChatChannel();            return;         }         if (m.logout) {            return;         }         if (m.riskupdate) {            isc.ask("The risk has been updated by another user. Retrieve updated data?", function (value) {               if (value) {                  getRiskAndDisplay(qoRiskController.riskID);                  qoRiskController.allowEditorChanges = true;                  startChatChannel();                  return;               } else {                  riskSaveBtn.setDisabled(true);                  riskSaveBtn.setTitle("<span style='color:#AAAAAA'>Save</span>");                  qoRiskController.allowEditorChanges = false;                  isc.say("Saving of updates disabled until risk has been refreshed with new data.", function () {                     startChatChannel();                     return;                  });               }            });         }         if (m.reportupdate) {            qoQRM.ConcurrentPane.setProject();            startChatChannel();            return;         }      },      error: function (jqXHR, textStatus, errorThrown) {         if (textStatus == "timeout") {            //            isc.say("Connection to the serever lost. You will need to login to Quay Risk Manager.", function () {            //               window.open("./login.jsp", "_self");            //            });            alert('SESSION TIMEOUT');         }      }   });}function calcProb(tempRisk, preMit) {   var days = (tempRisk.endExposure.getTime() - tempRisk.startExposure.getTime()) / (1000 * 60 * 60 * 24);   var alpha = 0;   var T = 0;   var type = 0;   if (preMit) {      type = tempRisk.liketype;   } else {      type = tempRisk.likepostType;   }   try {      if (type == 4) {         if (preMit) {            return tempRisk.likeprob * 100;         } else {            return tempRisk.likepostProb * 100;         }      } else {         if (preMit) {            alpha = tempRisk.likealpha;            T = tempRisk.liket;         } else {            alpha = tempRisk.likepostAlpha;            T = tempRisk.likepostT;         }         var alphat = alpha * (days / T);         var prob = 1 - (Math.exp(-alphat) * ((Math.pow(alphat, 0) / fact(0))));         return prob * 100;      }   } catch (e) {      alert("QRM Utils Line 2522" + e.message);      return -1.0;   }}function fact(n) {   if (n == 0) {      return 1;   }   return n * fact(n - 1);}function probFromMatrix(qprob, mat) {   // The the risk likelihood parameters to match the matrix settings.   var lowerLimit = 0.0;   var upperLimit = 0.0;   switch (parseInt(Math.floor(qprob), 10)) {      case 1:         lowerLimit = 0.0;         upperLimit = mat.probVal1;         break;      case 2:         lowerLimit = mat.probVal1;         upperLimit = mat.probVal2;         break;      case 3:         lowerLimit = mat.probVal2;         upperLimit = mat.probVal3;         break;      case 4:         lowerLimit = mat.probVal3;         upperLimit = mat.probVal4;         break;      case 5:         lowerLimit = mat.probVal4;         upperLimit = mat.probVal5;         break;      case 6:         lowerLimit = mat.probVal5;         upperLimit = mat.probVal6;         break;      case 7:         lowerLimit = mat.probVal6;         upperLimit = mat.probVal7;         break;      case 8:         lowerLimit = mat.probVal7;         upperLimit = mat.probVal8;         break;   }   var prob = lowerLimit + (upperLimit - lowerLimit) * (qprob - Math.floor(qprob));   return prob;}function probToMatrix(prob, mat) {   var qprob = 0.5;   if (mat.probVal1 != null && 0 <= prob && prob <= mat.probVal1 && mat.maxProb >= 1) {      qprob = 1.0 + (prob / mat.probVal1);   }   if (mat.probVal1 != null && mat.probVal2 != null && mat.probVal1 < prob && prob <= mat.probVal2 && mat.maxProb >= 2) {      qprob = 2.0 + ((prob - mat.probVal1) / (mat.probVal2 - mat.probVal1));   }   if (mat.probVal2 != null && mat.probVal3 != null && mat.probVal2 < prob && prob <= mat.probVal3 && mat.maxProb >= 3) {      qprob = 3.0 + ((prob - mat.probVal2) / (mat.probVal3 - mat.probVal2));   }   if (mat.probVal3 != null && mat.probVal4 != null && mat.probVal3 < prob && prob <= mat.probVal4 && mat.maxProb >= 4) {      qprob = 4.0 + ((prob - mat.probVal3) / (mat.probVal4 - mat.probVal3));   }   if (mat.probVal4 != null && mat.probVal5 != null && mat.probVal4 < prob && prob <= mat.probVal5 && mat.maxProb >= 5) {      qprob = 5.0 + ((prob - mat.probVal4) / (mat.probVal5 - mat.probVal4));   }   if (mat.probVal5 != null && mat.probVal6 != null && mat.probVal5 < prob && prob <= mat.probVal6 && mat.maxProb >= 6) {      qprob = 6.0 + ((prob - mat.probVal5) / (mat.probVal6 - mat.probVal5));   }   if (mat.probVal6 != null && mat.probVal7 != null && mat.probVal6 < prob && prob <= mat.probVal7 && mat.maxProb >= 7) {      qprob = 7.0 + ((prob - mat.probVal6) / (mat.probVal7 - mat.probVal6));   }   if (mat.probVal7 != null && mat.probVal8 != null && mat.probVal7 < prob && prob <= mat.probVal8 && mat.maxProb == 8) {      qprob = 8.0 + ((prob - mat.probVal7) / (mat.probVal8 - mat.probVal7));   }   return qprob;}function setMatrix(tolString, maxImpact, maxProb, val, svgDivID, treated){   var margin = { top: 0, right: 0, bottom: 0, left: 0 };   var width = 180 - margin.left - margin.right;   var height = 180 - margin.top - margin.bottom;   var data = new Array();      for (var prob = maxProb;prob > 0 ; prob -- ) {      for (var impact=1;impact <= maxImpact; impact++ ){         var index = (prob - 1) * maxImpact + impact - 1;         var tol = tolString.substring(index, index + 1);         data.push({"impact":impact, "prob": prob, "tol":tol, "val":val[(prob - 1) * maxImpact + impact - 1],"treated":treated} );      }   }         var gridSizeX = Math.floor(width / maxImpact);   var gridSizeY = Math.floor(height / maxProb);   d3.select(svgDivID+" svg").remove();      var svg = d3.select(svgDivID).append("svg")   .attr("width", width + margin.left + margin.right)   .attr("height", height + margin.top + margin.bottom)   .append("g")   .attr("transform", "translate(" + margin.left + "," + margin.top + ")");   var heatMap = svg.selectAll(".hour")   .data(data)   .enter().append("g")   .attr("class", "tolCell")   .attr("id", function(d) {return d.impact+"-"+d.prob;});   heatMap.append("rect")   .attr("x", function(d) { return (d.impact - 1) * gridSizeX; })   .attr("y", function(d) { return (maxProb - d.prob) * gridSizeY; })   .attr("rx", 2)   .attr("ry", 2)   .attr("class", function(d){      var root = "tol"+d.tol+" qrmMatElementID"+d.impact+d.prob;      if (d.treated){         return root+"T";      } else {         return root+"U";      }      })   .attr("width", gridSizeX)   .attr("height", gridSizeY)   .on("click", function(d){matrixFilter (d.impact, d.prob, d.treated, d.tol);});   heatMap.append("text")   .attr("x", function(d) { return (d.impact - 1) * gridSizeX +gridSizeX/2; })   .attr("y", function(d) { return (maxProb - d.prob) * gridSizeY +gridSizeY/2+5; })   .attr("class", "tolText")   .attr('pointer-events', 'none')   .style("text-anchor", "middle")   .on("click", function(d){matrixFilter (d.impact, d.prob, d.treated, d.tol);})   .text(function(d) { return (d.val > 0)?d.val:""; });   }function resetSelectedCell(){   //Reset Current Selected Cell   var resetClassName = "tol"+QRM.global.selectedCellTol+" qrmMatElementID"+QRM.global.selectedCellImpact+QRM.global.selectedCellProb;   if (QRM.global.selectedCellTreated){      resetClassName = resetClassName+"T";   } else {      resetClassName = resetClassName+"U";   }      d3.select("rect.selectedMatCell").attr("class",  resetClassName);}function preInit(){      // Add move to front capability to d3   d3.selection.prototype.moveToFront = function() {      return this.each(function(){      this.parentNode.appendChild(this);      });    };         Array.prototype.clear = function () {      this.length = 0;   };   Array.prototype.findAll = function (field, value) {      var subArray = new Array();      Ext.Array.each(this, function (item) {         if (item.field == value) {            subArray.push(item);         }      });      return subArray;   };   Array.prototype.getProperty = function(field){      res = new Array();      Ext.Array.each(this, function(item){         res.push(item[field]);      });      return res;   };   Array.prototype.getDataProperty = function(field){      res = new Array();      Ext.Array.each(this, function(item){         res.push(item.data[field]);      });      return res;   };   BrowserDetect.init();   QRM.global.distributionTypeMap = new Map();   QRM.global.distributionTypeMap.put("au.com.quaysystems.qrm.util.probability.NormalDistribution", "Normal");   QRM.global.distributionTypeMap.put("au.com.quaysystems.qrm.util.probability.TruncNormalDistribution", "Truncated Normal");   QRM.global.distributionTypeMap.put("au.com.quaysystems.qrm.util.probability.TriangularDistribution", "Triangular");   QRM.global.distributionTypeMap.put("au.com.quaysystems.qrm.util.probability.TriGenDistribution", "Truncated Triangular");   QRM.global.distributionTypeMap.put("au.com.quaysystems.qrm.util.probability.SimpleDistribution", "Simple");   QRM.global.distributionTypeMap.put("au.com.quaysystems.qrm.util.probability.UniformDistribution", "Uniform");   QRM.global.distributionTypeMap.put("au.com.quaysystems.qrm.util.probability.DiscreteDistribution", "Discrete");   QRM.global.distributionTypeMap.put("au.com.quaysystems.qrm.util.probability.NullDistribution", "No Distribution Defined");}d3.gantt = function() {   var FIT_TIME_DOMAIN_MODE = "fit";   var margin = {top : 20,right : 40, bottom : 20,     left : 150 };   var timeDomainStart = d3.time.day.offset(new Date(),-3);   var timeDomainEnd = d3.time.hour.offset(new Date(),+3);   var timeDomainMode = FIT_TIME_DOMAIN_MODE;// fixed or fit   var taskTypes = [];   var taskStatus = [];   var height = null;   var width = null;   var tickFormat = "%b %Y";   var keyFunction = function(d) { return d.startDate + d.taskName + d.endDate; };   var rectTransform = function(d) {return "translate(" + x(d.startDate) + "," + y(d.taskName) + ")"; };   var x = d3.time.scale().domain([ timeDomainStart, timeDomainEnd ]).range([ 0, width ]).clamp(true);   var y = d3.scale.ordinal().domain(taskTypes).rangeRoundBands([ 0, height - margin.top - margin.bottom ], .1);   var xAxis = d3.svg.axis().scale(x).orient("bottom").tickFormat(d3.time.format(tickFormat)).tickSubdivide(true).tickSize(8).tickPadding(8);   var yAxis = d3.svg.axis().scale(y).orient("left").tickSize(0);   var initTimeDomain = function(tasks) {      if (timeDomainMode === FIT_TIME_DOMAIN_MODE) {         if (tasks === undefined || tasks.length < 1) {            timeDomainStart = d3.time.day.offset(new Date(), -3);            timeDomainEnd = d3.time.hour.offset(new Date(), +3);            return;         }         tasks.sort(function(a, b) {return a.endDate - b.endDate; });         timeDomainEnd = tasks[tasks.length - 1].endDate;         tasks.sort(function(a, b) {return a.startDate - b.startDate; });         timeDomainStart = tasks[0].startDate;      }   };   var initAxis = function() {      x = d3.time.scale().domain([ timeDomainStart, timeDomainEnd ]).range([ 0, width ]).clamp(true);      y = d3.scale.ordinal().domain(taskTypes).rangeRoundBands([ 0, height - margin.top - margin.bottom ], .1);      xAxis = d3.svg.axis().scale(x).orient("bottom").tickFormat(d3.time.format(tickFormat)).tickSubdivide(true).tickSize(8).tickPadding(8);      yAxis = d3.svg.axis().scale(y).orient("left").tickSize(0);   };   function gantt(tasks, svgdiv, w,h) {      height = h - margin.top - margin.bottom-5;      width = w - margin.right - margin.left-5;      var dateFormatter = Ext.util.Format.dateRenderer('d M Y');      initTimeDomain(tasks);      initAxis();      var svg = d3.select(svgdiv)      .append("svg")      .attr("class", "chart")      .attr("width", width + margin.left + margin.right)      .attr("height", height + margin.top + margin.bottom)      .append("g")      .attr("class", "gantt-chart")      .attr("width", width + margin.left + margin.right)      .attr("height", height + margin.top + margin.bottom)      .attr("transform", "translate(" + margin.left + ", " + margin.top + ")");      svg.selectAll(".chart")      .data(tasks, keyFunction).enter()      .append("rect")      .attr("rx", 5)      .attr("ry", 5)      .attr("class", function(d){ return d.className; })       .attr("y", 0)      .attr("transform", rectTransform)      .attr("height", function(d) { return y.rangeBand(); })      .attr("width", function(d) { return (x(d.endDate) - x(d.startDate));})      .on('mouseover', function(d) { try {tooltipProb.text(d.taskName+" - Start Exposure: "+dateFormatter(d.startDate)+", End Exposure: "+dateFormatter(d.endDate));} catch(e){alert(e.message);} return tooltipProb.style("visibility", "visible"); })      .on("mousemove", function () { return tooltipProb.style("top", (event.pageY - 9) + "px").style("left", (event.pageX + 20) + "px");  })      .on("mouseout", function () { return tooltipProb.style("visibility", "hidden");})       .on("click", function (d) {          var e = d3.event;         if( !e.ctrlKey) return;         QRM.app.getCalenderController().listenForEditorChanges = true;         getRiskCodeAndDisplayInt(d.taskName);       });       svg.append("g")      .attr("class", "x axis")      .attr("transform", "translate(0, " + (height - margin.top - margin.bottom) + ")")      .transition()      .call(xAxis);      var title =  QRM.global.project.projectTitle;      if($$('cbDescendants').value){         title = title+" and Sub Projects";      }      svg.append("text")      .attr("text-anchor", "middle")      .style("font-size", "20px")      .style("font-weight", "normal")      .attr("transform", "translate(" + [ width/2, 4 ] + ")")      .text( title);            svg.append("g").attr("class", "y axis").transition().call(yAxis);      return gantt;   }   gantt.redraw = function(tasks) {      initTimeDomain(tasks);      initAxis();      var svg = d3.select("svg");      var ganttChartGroup = svg.select(".gantt-chart");      var rect = ganttChartGroup.selectAll("rect").data(tasks, keyFunction);      rect.enter()      .insert("rect",":first-child")      .attr("rx", 5)      .attr("ry", 5)      .attr("class", "bar")       .transition()      .attr("y", 0)      .attr("transform", rectTransform)      .attr("height", function(d) { return y.rangeBand(); })      .attr("width", function(d) {          return (x(d.endDate) - x(d.startDate));       }) ;      rect.transition()      .attr("transform", rectTransform)      .attr("height", function(d) { return y.rangeBand(); })      .attr("width", function(d) {          return (x(d.endDate) - x(d.startDate));       });      rect.exit().remove();      svg.select(".x").transition().call(xAxis);      svg.select(".y").transition().call(yAxis);      return gantt;   };   gantt.margin = function(value) {      if (!arguments.length)         return margin;      margin = value;      return gantt;   };   gantt.timeDomain = function(value) {      if (!arguments.length)         return [ timeDomainStart, timeDomainEnd ];      timeDomainStart = +value[0], timeDomainEnd = +value[1];      return gantt;   };   gantt.timeDomainMode = function(value) {      if (!arguments.length)         return timeDomainMode;      timeDomainMode = value;      return gantt;   };   gantt.taskTypes = function(value) {      if (!arguments.length)         return taskTypes;      taskTypes = value;      return gantt;   };   gantt.taskStatus = function(value) {      if (!arguments.length)         return taskStatus;      taskStatus = value;      return gantt;   };   gantt.width = function(value) {      if (!arguments.length)         return width;      width = +value;      return gantt;   };   gantt.height = function(value) {      if (!arguments.length)         return height;      height = +value;      return gantt;   };   gantt.tickFormat = function(value) {      if (!arguments.length)         return tickFormat;      tickFormat = value;      return gantt;   };   return gantt;};